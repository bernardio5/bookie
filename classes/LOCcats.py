import os
import sys


from shutil import copyfile

from classes.paths import paths
from classes.book import book
from classes.scanner import scanner


# reads LOC categories & creates a topics list with subtopics lists
# each LOC mark is a first letter, a second letter or a number, then a text description.

# there are two files: LOCfamilies, 517 lines, and LOCtopics, 43123 lines

# the allLOCsubjects class makes a tree: 25 first-letter "orders". 
#   each order contains the two-letter combinations in that section: "families"
#   each family contains all the member entries in LOCtopics in a list: "topics"
#   each topic contains a list of books, from which we get a list of authors. 

# The library's book ordering is order-family-topic-author-title
# Books with multiple topic strings occur that many times. 
# The call numbers are generated by concatenating the two letters, a topic number, 
# author name up to 10 characters, book title up to 10 characters
# (what about multiple editions? what about re-scans?)

# E and F are different: they use numbers, and the numbers are of an outline. 
# I've manually tagged them as level 1,2,3, corresponding to family, topic, and SUBTOPIC
# and even a few SUBSUBTOPICS! sheeeit. 


# differences from brick & mortar libraries
# 1) as many copies as you like of everything=> books have multiple locations. 
# 2) no loaning => no need for unique IDs (editions, etc) 
# 3) updating every single classification is as easy as re-running the script



############### steps to make the catalog

# load the orders & families from the LOCfamilies 
# -- init the orders in one pass & set marks
# -- second pass, make families in orders & set those marks

# load the topics from LOCtopics
# -- init into arrays in families
# this is the "topic tree"

# step through books
# -- make a book, then a minibook
# -- save minibook in array indexed by gutenID
# -- for each topic
# -- -- find topic (or add new) 

# traverse topic tree; set marks for all topics; these are orderfamily-topicnumber

# step through books by gutenID
# -- for each author
# -- -- for each topic
# -- -- -- find topic in the tree; add to topic list for that book
# -- -- -- add book to topic

# for all topics, 
# -- sort books by author, then title. 
# -- make a mark for each book in the tpic
# -- copy those marks into the gid-indexed book list

# for each book in gid list, for each mark, copy into genus 

# traverse the tree, outputting mark/gid pairs

# statistics- gathering: break into ~10k chunks of text
# top-down:
# make HTML for order/family/topic

# bottom-up
# generate HTML? PHP? for books, topics, 
# HTML for each book contains related books: all by that author, all in that topic.


# will have one of these per book, stored in a gid-indexed array,
# and, multiply, in the order/fam/gen tree
class LOCminiBook:
    def __init__(self, line):
    	self.authors = []
    	self.title = ""
    	self.topics = []
        self.genusMarks = []
        self.callnumbers = [] # one for each author,topic 
        self.gutenID = 0

    def makeFromBigBook(self, gid, bbRecPath):
        bb = book()
        bb.readGbXML(gid, xmlfile)

    def addCall(self, callnumber):





# one per author/subj/title 
class LOCcallNumber:
    def __init__(self):
        self.LOC = ""
        self.micro = 0
        self.author = 0
        self.boa = 0
    # the nth distrubted number of count, equispaced into range 4096
    def scaler(nth, count):
        return ((nth+1) * (4094/(count+2))) + 1

    # init from string of form LOC-micro#-author#-boa
    def parse(): 
    # parsable string from self data
    def parsable(): 





# one per topic per book per author? 
class LOCauthor:
    def __init__(self, line):
 		mark = "AB.F00F.authorTag" # mark of owner Family + self's number
        books = []
    # given a subject description string, return -1 for can't find, or an index? what. 
    def owns(self, string):




# one per text-described topic in two-letter genus
class LOCGenus: 
    def __init__(self, line):
 		mark = "AB.F00F" # mark of owner Family + self's number
        description = "-" # text description of self
        books = [] # all the books in the topic
        authors = [] # all first authors of the book
        books = []
    # given a subject description string, return -1 for can't find, or an index? what. 
    def matches(self, string):

    def initFromLOCcategory(self, string): 




# one per two-letter LOC classification (+number, for E & F)
class LOCFamily: 
    def __init__(self, line):
    	mark = "AB"  # the letters of
    	description = "-" # text description of
        geni = [] # list of genuses in the family
        name = "-" # name string for humans
        thisid = "-" # string used for matching
        nextid = "-" # for E and F
        isSimple = True
        indentation = 0
    # given a subject description string, return -1 for can't find, or an index? what. 
    def matches(self, string):


# topic line format: mark string, colon, space, remainder of line is topic
# AC: China -- Politics and government -- To 221 B.C.
    def initFromLOCtopic(self,string):


# format for LOCcategories initial string + space + topic string
# A References & Periodicals
# AC Collections, Series, & Collected Works  
# string length==1 => order name
# string length==2, second char is letter => genus name
# string length>1, second char is number => E/F genus name
#   topic string begins with -, --, --- => family, genus,  
    def initFromLOCcategory(self, string): 

    def initFromBook(self, minibook): 




# one per single-letter LOC classification
class LOCOrder:
    def __init__(self, line):
    	mark = "A"  # the letter
        description = "-" # text description of 
        families = [] # list of families in 
    # given a subject description string, return -1 for can't find, 
    # or an index into families 
    def matches(self, LOCtopic):
    def initFromLOCtopic(self,string):




class LOCtree:
    def __init__(self):
        self.lineCounter = 0
        self.orders = []
        thePaths = paths()
        with open(thePaths.LOCpath) as f:
            content = f.readlines()
            self.lineCounter = len(content)
            for ln in content:
                sb = subject()
                sb.init(ln)
                self.subjects.append(sb)

# topic line format: mark string, colon, space, remainder of line is topic
# AC: China -- Politics and government -- To 221 B.C.
    def initFromLOCtopics(self, path):
        # read into line array, det what each line defines, create thus


# format for LOCcategories initial string + space + topic name
# A References & Periodicals
# AC Collections, Series, & Collected Works  
# string length==1 => order name
# string length==2, second char is letter => genus name
# string length>1, second char is number => E/F genus name
#   topic name begins with -, --, --- => family, genus,  
    def initFromLOCcategories(self, path):
        # read into line array, det what each line makes, thus thus


# find genus in tree, add if not found 
    def addBook(self, minibook):


        





class library:
    def __init__(self):
        self.scanner = scanner()
        thePaths = paths()
        self.covers = os.listdir(thePaths.coversDir)
        self.clips = os.listdir(thePaths.clipDir)


    def readAll(self):
        notDone = True
        ctr = 1000  # set to not 1 to start in the middle of the list
        nco = len(self.covers)
        ncl = len(self.clips)
        self.scanner.skipTo(ctr)
        while notDone:
            ctr = ctr +1
            # when debugging, this line stops after book 120
            if (ctr>1100): # comment out to do all books
                notDone = False
            pt = self.scanner.getNextPath()
            if (len(pt)>0 and not (".delete" in pt)):
                booky = book()
                booky.readGbXML(self.scanner.gbID, pt)
                if (booky.langOK() and booky.scanGBDir()==0):
                    #if (ctr%30==0):
                    #    print(ctr, ":", booky.gutenId)
                    coverImg = self.covers[ctr%nco]
                    clipImg = self.clips[(ctr+500)%ncl]
                    if (booky.makeEpub(coverImg, clipImg)==0):
                        print("skipped id ", booky.gutenId)
            else: 
                notDone = False


print("defined")

# everything defines ok; run it
def main():
    lb = library()
    lb.readAll()

if __name__ == "__main__":   
    main() 

print("ok then")