import os
import sys


from shutil import copyfile

from classes.paths import paths
from classes.book import book
from classes.scanner import scanner


# reads LOC categories & creates a topics list with subtopics lists
# each LOC mark is a first letter, a second letter or a number, then a text description.

# there are two files: LOCfamilies, 517 lines, and LOCtopics, 43123 lines
# but the topics list is oddly gappy, so let's just use the subjects in the books.

# how to sort? 

# the allLOCsubjects class makes a tree: 25 first-letter "orders". 
#   each order contains the two-letter combinations in that section: "families"
#   each family contains all the member entries in LOCtopics in a list: "topics"
#   each topic contains a list of books, from which we get a list of authors. 

# The library's book ordering is order-family-topic-author-title
# Books with multiple topic strings occur that many times. 
# The call numbers are generated by concatenating the two letters, a topic number, 
# author name up to 10 characters, book title up to 10 characters
# (what about multiple editions? what about re-scans?)

# E and F are different: they use numbers, and the numbers are of an outline. 
# I've manually tagged them as level 1,2,3,4 corresponding to family, topic, and SUBTOPIC
# There are not many subtopics, like, 9. I'm just treating them as topics. 


# differences from brick & mortar libraries
# 1) as many copies as you like of everything=> books have multiple locations. 
# 2) no loaning => no need for unique IDs (editions, etc) 
# 3) updating every single classification is as easy as re-running the script



############### steps to make the catalog

# load the orders & families from the LOCfamilies 
# -- init the orders in one pass & set marks
# -- second pass, make families in orders & set those marks

# step through books
# -- make a book, then a minibook
# -- save minibook in array indexed by gutenID
# -- for each topic
# -- -- find topic or add new

# traverse topic tree; set marks for all topics; these are orderfamily-topicnumber

# step through books by gutenID
# -- for each author
# -- -- for each topic
# -- -- -- find topic in the tree; add to topic list for that book
# -- -- -- add book to topic

# for each family
# -- process topics to enable easier lookups?
# -- alphabetize topics by least-common word? 
# -- group by ? make links by? 
# -- nat lang actions? 

# -- sort books by author, then title. 
# -- make a mark for each book in the tpic
# -- copy those marks into the gid-indexed book list

# for each book in gid list, for each mark, copy into genus 

# traverse the tree, outputting mark/gid pairs

# statistics- gathering: break into ~10k chunks of text
# top-down:
# make HTML for order/family/topic

# bottom-up
# generate HTML? PHP? for books, topics, 
# HTML for each book contains related books: all by that author, all in that topic.


# will have one of these per book, stored in a gid-indexed array,
# and, multiply, in the order/fam/gen tree
class LOCminiBook:
    def __init__(self, line):
    	self.authors = []
    	self.title = ""
    	self.topics = []
        self.family = ""
        self.gutenId = 0
        self.valid = false

    def makeFromBigBook(self, gid, bbRecPath):
        booky = book()
        booky.readGbXML(gid, bbRecPath)
        if (booky.langOK() and booky.scanGBDir()==0):
            self.gutenId = booky.gutenId
            self.title = booky.title
            for s in booky.subjects:
                self.topics = s
                if (s.contains("LCC:")):
                    pts = s.split(':')
                    self.family = pts[1]
                    self.valid = true
            for a in booky.auths:
                self.topic = a.name
        # to do: author link? multiple LCC: ? 



# one per author/subj/title 
class LOCcallNumber:
    def __init__(self):
        self.LOC = ""
        self.micro = 0
        self.author = 0
        self.boa = 0
    # the nth distrubted number of count, equispaced into range 4096
    def scaler(nth, count):
        return ((nth+1) * (4094/(count+2))) + 1

    # init from string of form LOC-micro#-author#-boa
    def parse(): 
    # parsable string from self data
    def parsable(): 





# one per topic per book per author? 
class LOCauthor:
    def __init__(self, line):
 		mark = "AB.F00F.authorTag" # mark of owner Family + self's number
        books = []
    # given a subject description string, return -1 for can't find, or an index? what. 
    def owns(self, string):




# one per text-described topic in two-letter genus
class LOCTopic: 
    def __init__(self, line):
 		mark = "AB.F00F" # mark of owner Family + self's number
        description = "-" # text description of self
        books = [] # all the books in the topic
        authors = [] # all first authors of the book
        books = []
    # given a subject description string, return -1 for can't find, or an index? what. 
    def matches(self, string):

    def initFromLOCcategory(self, string): 




# one per two-letter LOC classification (+number, for E & F)
class LOCfamily: 
    def __init__(self, line):
    	mark = line[0:2]  # the letters of
    	description = [3:] # text description of

    # given a subject description string, return -1 for can't find, or an index? what. 
    def matches(self, string):

# topic line format: mark string, colon, space, remainder of line is topic
# AC: China -- Politics and government -- To 221 B.C.
    def initFromLOCtopic(self,string):

# format for LOCcategories initial string + space + topic string
# A References & Periodicals
# AC Collections, Series, & Collected Works  
# string length==1 => order name
# string length==2, second char is letter => genus name
# string length>1, second char is number => E/F genus name
#   topic string begins with -, --, --- => family, genus,  
    def initFromLOCcategory(self, string): 

    def initFromBook(self, minibook): 





# one per single-letter LOC classification
class LOCorder:
    def __init__(self, line):
    	mark = line[0:1]
        description = line[2:] # text description of this order
        families = [] # list of families in 
    # given a subject description string, return -1 for can't find, 
    # or an index into families 

    def addFamily(self, line):
        fam = LOCfamily(line)

    def matches(self, tp):
        if (self.mark==tp[0:1]):
            return true
        return false

    def addBook(self, bk):
        for fm in self.families:
            if (bk.)



# all of the orders/families/topics; all of the books. 
class LOCtree:
    def __init__(self):        
        self.thePaths = paths()
        file = open(“testfile.txt”, “r”) 
        lines = file.readlines() 
        for ln in lines:
            if ln[1] == ' ':
                ord = LOCorder(ln)
            else: 
                ord.addFamily(ln)

# topic line format: mark string, colon, space, remainder of line is topic
# AC: China -- Politics and government -- To 221 B.C.
    def addBook(self, book):
        for s in book.topics:
            f = s[0]
            ind = place of s[0] in abc




        





class library:
    def __init__(self):
        self.scanner = scanner()
        self.thePaths = paths()
        self.theTree = LOCtree()
        self.gidList = []
    # traverse all books, a copy for each book topic
    def buildCats(self):
        notDone = True
        ctr = 0
        self.scanner.skipTo(ctr)
        while notDone:
            ctr = ctr +1
            # when debugging, this line stops after book 120
            if (ctr>1100): # comment out to do all books
                notDone = False
            pt = self.scanner.getNextPath()
            if (len(pt)>0 and not (".delete" in pt)):
                # read in the book if you can
                minibook = LOCminiBook()
                minibook.makeFromBigBook(booky)
                if (minibook.valid):
                    self.gidList.append(minibook)
                    self.theTree.addBook(minibook)


    def recitation(self):
        notDone = True

        while notDone:
            ctr = ctr +1
            # when debugging, this line stops after book 120
            if (ctr>1100): # comment out to do all books
                notDone = False
            pt = self.scanner.getNextPath()
            if (len(pt)>0 and not (".delete" in pt)):
                    #if (ctr%30==0):
                    #    print(ctr, ":", booky.gutenId)
                    coverImg = self.covers[ctr%nco]
                    clipImg = self.clips[(ctr+500)%ncl]
                    if (booky.makeEpub(coverImg, clipImg)==0):
                        print("skipped id ", booky.gutenId)
            else: 
                notDone = False




print("defined")

# everything defines ok; run it
def main():
    lb = library()
    lb.buildCats()
    lb.recitation()

if __name__ == "__main__":   
    main() 

print("ok then")