import os
import sys
from shutil import copyfile
import xml.etree.ElementTree as ET 
import math
from classes.paths import paths
from classes.book import book
from classes.scanner import scanner


# reads LOC categories & creates a topics list with subtopics lists
# each LOC mark is a first letter, a second letter or a number, then a text description.

# there are two files: LOCfamilies, 517 lines, and LOCtopics, 43123 lines
# but the topics list is oddly gappy, so let's just use the subjects in the books.

# how to sort? 

# the allLOCsubjects class makes a tree: 25 first-letter "orders". 
#   each order contains the two-letter combinations in that section: "families"
#   each family contains all the member entries in LOCtopics in a list: "topics"
#   each topic contains a list of books, from which we get a list of authors. 

# The library's book ordering is order-family-topic-author-title
# Books with multiple topic strings occur that many times. 
# The call numbers are generated by concatenating the two letters, a topic number, 
# author name up to 10 characters, book title up to 10 characters
# (what about multiple editions? what about re-scans?)

# E and F are different: they use numbers, and the numbers are of an outline. 
# I've manually tagged them as level 1,2,3,4 corresponding to family, topic, and SUBTOPIC
# There are not many subtopics, like, 9. I'm just treating them as topics. 


# differences from brick & mortar libraries
# 1) as many copies as you like of everything=> books have multiple locations. 
# 2) no loaning => no need for unique IDs (editions, etc) 
# 3) updating every single classification is as easy as re-running the script



############### steps to make the catalog

# load the orders & families from the LOCfamilies 
# -- init the orders in one pass & set marks
# -- second pass, make families in orders & set those marks

# step through books
# -- make a book, then a minibook
# -- save minibook in array indexed by gutenID
# -- for each topic
# -- -- find topic or add new

# traverse topic tree; set marks for all topics; these are orderfamily-topicnumber

# step through books by gutenID
# -- for each author
# -- -- for each topic
# -- -- -- find topic in the tree; add to topic list for that book
# -- -- -- add book to topic

# for each family
# -- process topics to enable easier lookups?
# -- alphabetize topics by least-common word? 
# -- group by ? make links by? 
# -- nat lang actions? 

# -- sort books by author, then title. 
# -- make a mark for each book in the tpic
# -- copy those marks into the gid-indexed book list

# for each book in gid list, for each mark, copy into genus 

# traverse the tree, outputting mark/gid pairs

# statistics- gathering: break into ~10k chunks of text
# top-down:
# make HTML for order/family/topic

# bottom-up
# generate HTML? PHP? for books, topics, 
# HTML for each book contains related books: all by that author, all in that topic.


# will have one of these per book, stored in a gid-indexed array,
# and, multiply, in the order/fam/gen tree
class LOCminiBook:
    def __init__(self):
        self.authors = []
        self.title = ""
        self.topics = []
        self.lcc = "-"
        self.gutenId = 0
        self.valid = False
        self.dir = ""
        self.path = ""

    def duplicate(self):
        res = LOCminiBook()
        for a in self.authors:
            res.authors.append(a.duplicate())
        res.title = self.title
        for t in self.topics: 
            res.topics.append(t)
        res.lcc = self.lcc
        res.gutenId = self.gutenId
        res.valid = self.valid
        return res


    def makeFromBigBook(self, booky):
        if (booky.langOK() and booky.scanGBDir()==0):
            for a in booky.auths:
                self.authors.append(a.duplicate())
            self.title = booky.title
            self.gutenId = booky.gutenId
            for s in booky.subjects:
                if (s.find("LCC: ")!=-1):
                    if (self.lcc!="-"):
                        print("multiple LCCs!")
                    self.lcc = s[5:]
                    self.valid = True
                if (s.find("LCSH: ")!=-1):
                    tpc = s[6:]     # self.topics only contains LCSH strings.
                    self.topics.append(tpc)
                    self.valid = True
        if (self.title.find("Punchinello")!=-1):
            self.valid = False # seriously: *fuck* those guys
        thePaths = paths()
        digits = '%05d' % int(self.gutenId)
        self.dir = thePaths.htmlDir + digits[0:1] + "\\" + digits[1:3] + "\\" + digits[3:] + "\\"
        self.path = self.dir + "index.html"

    def recitation(self):
        print("      --", self.title)


    def listRecitation(self):
        print(self.title, " gid:", self.gutenId, "LCC:", self.lcc )
        for s in self.topics:
            print("  ", s)


    def makeHTMLblock(self, ownerElement):
        div = ET.SubElement(ownerElement, "div")
        # title as link, gid #, other subjects? 


    def makeHTML(self):
        html = ET.Element("html")
        html.set('xmlns', "http://www.w3.org/1999/xhtml")
        html.set('xml:lang', "en")
        head = ET.SubElement(html, "head")
        title = ET.SubElement(head, "title")
        title.text = "Book page: " + self.title
        meta = ET.SubElement(head, "meta")
        meta.set('name', "calibre:cover")
        meta.set('content', "true")
        body = ET.SubElement(html, "body")
        img =ET.SubElement(body, "img")
        img.set("src", "cover.png")
        # data and links? 
        tree = ET.ElementTree(html)
        if not os.path.exists(self.dir):
            os.makedirs(self.dir)
        tree.write(self.path)


class LOCauthorSet:
    def __init__(self):
        # maybe something more efficient, maybe just sit on yr hands.
        self.auths = []
    
    def add(self, aut, gid):
        for a in self.auths:
            if a.matches(aut):
                a.workIds.append(gid)
                print('adding to')
                return
        newAut = aut.duplicate()
        newAut.workIds.append(gid)
        self.auths.append(aut.duplicate())
        print('added new author #', len(self.auths))

    def length(self):
        return len(self.auths)

    def nth(self, n):
        return self.auths[n]

    def makeHTMLblock(self, author, ownerElement):
        div = ET.SubElement(ownerElement, "div")
        # name, dates wikilink, 


    def makeHTMLs(self):
        for at in self.auths:
            if not os.path.exists(at.htmlDir()):
                os.makedirs(at.htmlDir())
            html = ET.Element("html")
            html.set('xmlns', "http://www.w3.org/1999/xhtml")
            html.set('xml:lang', "en")
            head = ET.SubElement(html, "head")
            title = ET.SubElement(head, "title")
            title.text = "Author page" + at.name
            meta = ET.SubElement(head, "meta")
            meta.set('name', "calibre:cover")
            meta.set('content', "true")
            body = ET.SubElement(html, "body")
            img =ET.SubElement(body, "img")
            img.set("src", "cover.png")
            # data and links? 
            tree = ET.ElementTree(html)
            tree.write(at.htmlPath())


# one per text-described topic in two-letter genus
class LOCtopic: 
    def __init__(self):
        self.doubleMark = "AB"
        self.mark = "AB.F00F" # mark of owner Family + self's number
        self.description = "-" # text description of self
        self.books = [] # all the books in the topic
        self.path = ".html"
        
    def matches(self, bk):
        res = False
        for sb in bk.topics:
            if (sb==self.description):
                res = True
        return res

    def maybeAddBook(self, bk): 
        res = False
        if (self.matches(bk)):
            self.books.append(bk.duplicate())
            res = True
        return res

    def setFromBook(self, dblMark, subj, bk): 
        self.doubleMark = dblMark
        self.description = subj
        self.books.append(bk.duplicate())
        thePaths = paths()
        self.path = thePaths.htmlDir + "\\topics\\" + self.mark + ".html"
 
    def recitation(self):
        print("   ", self.doubleMark, " ", self.description, " count:", len(self.books))
        for b in self.books:
            b.recitation()
        return len(self.books)


        # want books in topic, related topics, link up, link down
    def makeHTML(self):
        file = open(self.path, "w") 
        file.write("<!DOCTYPE html>")
        file.write("<html>")
        file.write("<body>")

        file.write('<h3>' + self.mark + ':' + self.description + '</h3><br/>')
        for sn in self.books:
            file.write('<a href="' + sn.path + '.html">')
            file.write(sn.gutenId + ':' +sn.title + '</a><br/>')
        file.write("</body>")
        file.write("</html>")
        file.close() 
        


# one per two-letter LOC classification (or 1+number, for E & F)
class LOCdouble: 
    def __init__(self, line):
        # oh, nope. marks can be more than 2 chars. 
        spot = line.find(' ')  # the letters of
        self.mark = line[0:spot]
        self.description =line[(spot+1):]
        thePaths = paths()
        self.path = thePaths.htmlDir + "\\topics\\" + self.mark + ".html"
        self.topics = []

    # given a subject description string, return -1 for can't find, or an index? what. 
    def matches(self, bk):
        booksMark = bk.lcc[0:2]
        if (self.mark==booksMark):
            return True
        return False

    def maybeAddBook(self, bk):
        toAppend = []
        if (self.matches(bk)):
            print("adding ", bk.gutenId, self.mark, "=", bk.lcc)
            hasMatch = False
            # if self.topics is empty, just add all the book's topics
            if (len(self.topics)==0):
                for btp in bk.topics:
                    newt = LOCtopic()
                    newt.setFromBook(self.mark, btp, bk)
                    self.topics.append(newt)
            else:
                # otherwise, for each book topic, maybe add to existing
                toAppend = []
                notAdded = True
                for tpc in self.topics:
                    if tpc.maybeAddBook(bk):
                        notAdded = False
                # add new LOC topics for all book topics for all books that didn't find a match
                if notAdded:
                    for tp in bk.topics:
                        newt = LOCtopic()
                        newt.setFromBook(self.mark, tp, bk)
                        self.topics.append(newt)

    def recitation(self):
        print(self.mark, " -- ", self.description, " topics " + str(len(self.topics)))
        for t in self.topics:
            t.recitation()
        

    def makeHTML(self):
        file = open(self.path, "w") 
        file.write("<!DOCTYPE html>")
        file.write("<html>")
        file.write("<title>workly.com/projects list</title>")
        file.write('<link rel="stylesheet" href="styles.css">')
        file.write("<body>")

        file.write('<h3>' + self.mark + ':' + self.description + '</h3><br/>')
        for sn in self.topics:
            sn.makeHTML()
            file.write('<a href="' + sn.mark + '.html">')
            file.write(sn.mark + ':' +sn.description + '</a><br/>')
        file.write("</body>")
        file.write("</html>")
        file.close() 
        

# one per single-letter LOC classification
class LOCsingle:
    def __init__(self, line):
        self.mark = line[0:1]
        self.description = line[2:] # text description of this order
        self.doubles = [] # list of LOCdoubles in 
        thePaths = paths()
        self.path = thePaths.htmlDir + "\\topics\\" + self.mark + ".html"

    def addDouble(self, line):
        d = LOCdouble(line)
        self.doubles.append(d)

    def matches(self, bk):
        booksMark = bk.lcc[0:1]
        if (self.mark==booksMark):
            return True
        return False

    def maybeAddBook(self, bk):
        if (self.matches(bk)):
            for db in self.doubles:
                db.maybeAddBook(bk)

    def recitation(self):
        print(self.mark + " -- " + self.description)
        print(" doubles contained: " + str(len(self.doubles)))
        for d in self.doubles:
            d.recitation()
        

    def makeHTML(self):
        file = open(self.path, "w") 
        file.write("<!DOCTYPE html>")
        file.write("<html>")
        file.write("<body>")

        file.write('<h3>' + self.mark + ':' + self.description + '</h3><br/>')
        for sn in self.doubles:
            sn.makeHTML()
            file.write('<a href="' + sn.mark + '.html">')
            file.write(sn.mark + ':' +sn.description + '</a><br/>')
        file.write("</body>")
        file.write("</html>")
        file.close() 
        


# all of the orders/families/topics; all of the books. 
class LOCtree:
    def __init__(self):        
        self.thePaths = paths()
        self.singles = []
        file = open(self.thePaths.dataDir + "LOCfams.txt", "r") 
        lines = file.readlines() 
        for ln in lines:
            if ln[1] == ' ':
                ord = LOCsingle(ln)
                self.singles.append(ord)
            else: 
                ord.addDouble(ln)

    def addBook(self, book):
        for sn in self.singles:
            sn.maybeAddBook(book)

    def recitation(self):
        print("------------------")
        for s in self.singles:
            s.recitation()


    def makeHTML(self):
        targ = self.thePaths.htmlDir + "index.html"
        file = open(targ, "w") 
        file.write("<!DOCTYPE html>")
        file.write("<html>")
        file.write("<body>")
        file.write("<h3>Library root</h3><br/>")
        for sn in self.singles:
            sn.makeHTML()
            file.write('<a href="' + sn.path + '">')
            file.write(sn.mark + ':' +sn.description + '</a><br/>')
        file.write("</body>")
        file.write("</html>")
        file.close() 



class library:
    def __init__(self):
        self.scanner = scanner()
        self.thePaths = paths()
        self.theTree = LOCtree()
        self.gidList = []
        self.covers = os.listdir(self.thePaths.coversDir)
        self.clips = os.listdir(self.thePaths.clipDir)
        self.authorSet = LOCauthorSet()

    # traverse all books
    def buildCats(self):
        nco = len(self.covers)
        ncl = len(self.clips)
 
        notDone = True
        ctr = 150
        self.scanner.skipTo(ctr)
        while notDone:
            ctr = ctr +1
            if (ctr>650): # comment out to do all books
                notDone = False
            pt = self.scanner.getNextPath()
            if (len(pt)>0 and not (".delete" in pt)):
                # read in the book if you can
                fullbook = book()
                fullbook.readGbXML(self.scanner.gbID, pt)
                if fullbook.isValid():
                    minibook = LOCminiBook()
                    minibook.makeFromBigBook(fullbook)
                    if (minibook.valid):
                        print("isValid")
                        self.gidList.append(minibook)
                        self.theTree.addBook(minibook)
                        coverImg = self.covers[ctr%nco]
                        clipImg = self.clips[(ctr+500)%ncl]
                        if (fullbook.makeEpub(coverImg, clipImg)==1):
                            print("made pub")
                            targetDir = minibook.dir
                            if not os.path.exists(targetDir):
                                os.makedirs(targetDir)
                
                            #if (not os.path.isdir(targetDir)):
                                # make dir -- implied in copy?
                            src_files = os.listdir(targetDir) # clear out dir
                            for fn in src_files:
                                pt = targetDir + "\\" + fn
                                if os.path.isfile(pt):
                                    os.remove(pt)

                            # move book to book HTML dir stack
                            fromPt = fullbook.bookPath
                            toPt = targetDir + "\\" + fullbook.safeFn(fullbook.bookTag()) + ".epub"
                            print('copying fromto', fromPt, toPt)
                            if os.path.isfile(fromPt):
                                copyfile(fromPt, toPt)
                                os.remove(fullbook.bookPath)

                            # copy cover image over, too
                            fromPt = self.thePaths.scratchDir + "OEBPS\\cover.png"
                            toPt = targetDir + "\\cover.png"
                            print('copying fromto', fromPt, toPt)
                            if os.path.isfile(fromPt):
                                copyfile(fromPt, toPt)

                            # and then add the book's html
                            minibook.makeHTML()

                            # for each author, add to auth list.
                            for aut in fullbook.auths:
                                print('adding', aut.name)
                                self.authorSet.add(aut, fullbook.gutenId)


    # authors have a root page, then one page per first letter, then pages per author last name
    # author lastname pages have
    # per author, stats block/wiki page, book list, topic list    
    # def buildAuthors(self):
        # for each book, add to author list
        # sort authors
        # output author root
        # output author first-letter pages
        # output 

    # def buildTopics(self):
        # gah, who knows

    def recitation(self):
        print("book list by gid:   -------------------------------------")
        for b in self.gidList:
            b.listRecitation()
        print("tree:               -------------------------------------")
        self.theTree.recitation()


    def makeHTML(self):
        for b in self.gidList:
            b.makeHTML()
        self.theTree.makeHTML()


    def makeAuthors(self):
        self.authorSet.makeHTMLs()



print("defined")

# everything defines ok; run it
def main():
    lb = library()
    lb.buildCats()
    lb.makeHTML()
    lb.makeAuthors()

if __name__ == "__main__":   
    main() 

print("ok then")